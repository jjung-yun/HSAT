def dfs(N, lst): # 재귀함수 : 1.종료조건 2.정답처리
    if N==m: #N이 재귀를 통해 증가하여 내가 뽑을 개수인 m에 도달하면 종료
        ans.append(lst) # 정답 리스트인 ans에 부분 정답 (1줄) lst를 append함.
        return     # 재귀함수는 return 을 통해 나감.

    # 종료조건이 아닐 때는?
    for j in range(1,n+1): # 1~n 까지 중복되지 않은 값 찾기
        if v[j]==0: # 방문 안했다면?
            v[j]=1 # 재귀 되는 동안은 방문한 값은 1이 됨
            dfs(N+1, lst+[j]) # 재귀할 때, n은 1증가, lst에 j 값이 추가된 리스트를 인수로 씀.
            v[j]=0 # 다시 풀어주기
            # 재귀 끝에는 뽑고싶은 개수 m=2 라면 N==2 일 때 ans에 집어두고 return 됨.
            # return 되면서는 v[j]=0 만 수행됨.


            # lst.append(j)는 lst에 j를 추가 / return 값은 없음
            # lst+[j] 는 lst 변화 x / return 값은 lst에 j값이 추가된 리스트
            

n,m=map(int,input().split())
ans=[]
v=[0]*(n+1) # n+1개의 0 을 가진 리스트

dfs(0, []) # 시작값은 0, 시작 리스트는 빈리스트
            #끝날 때는, 1.중복되지 않은 값 1~n => 인덱스 맞추려고 v[j]*(n+1) / 2.dfs 재귀 횟수 m 
            #재귀할 때, N==m 이 돼야 종료됨
            #n=1일 때 m만큼 재귀 (1,2) (1,3) (1,4) (n=4, m=2일 때)

            # n=4, m=2일 때 재귀 과정
            # dfs(0, [])
            # j=1 이고, v[1]=1 이됨

            # dfs [1, [1]]
            # v[1]=1 이라 for j에서 다음값 => j=2, v[2]=1 이 됨.

            # dfs(2, [1,2])
            # 2==m 이됨 => [1,2]를 ans에 append 및 종료 (재귀가 return 되면서 v[2] 값 0으로 초기화)

            # dfs(1, [1]) 까지 return 후, v[2]=0 , 그리고 for에 의해 j=3
            # dfs(2, [1,3]) => ans.append([1,3])
            # dfs(1, [1]) return , v[3]=0, for에 의해 j=4 (n=4까지)


            # 위까지 j=1 이고, j=2 시작
            # v[2]=1
            # dfs(1,[2]) #(중요) for만 1증가이고 dfs(0,[]) 은 바뀌지 않음.
            # dfs(2,[2,1]) 에서 종료
            
            # for에서 n이 4이므로 (1,2) (1,3) (1,4) (2,1) ~ (4,3) 까지 수행.



#print(*ans)
# 2차원 리스트 한번에 출력하는 방법
for lst in ans:
    print(*lst)